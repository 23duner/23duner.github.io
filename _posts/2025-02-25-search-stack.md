---
title: 
layout: post
post-image: ""
description: 你甚至能在碎碎念博客里找到考研相关内容，某些博主上了两节数学课之后蓦然发现自己是数学系的学生
tags:
- 卡特兰数
- 栈
- 408
---

从栈的数学性质到catalan数的应用，数学系的倔强之翻出来卡特兰数全家。  
数学如此简洁 

$\frac{1}{n+1} C_{2n}^{n}$


# 有哪些问题，解等于卡特兰数？

卡特兰数是组合数学中一个常出现在各种计数问题中的数列，以下是关于它的介绍：


- **括号匹配问题**：n对相同括号的合法匹配方式数量为卡特兰数\(C_n\)。如\(n = 2\)时，有\(()()\)和\((())\)这\(2\)种合法匹配，\(C_2 = 2\)。
- **二叉树的形态计数**：n个节点的二叉树的不同形态数量是卡特兰数C_n。
- **出栈序列问题**：n个元素**进栈序列**固定，其不同出栈序列的数量为卡特兰数C_n。（分不清左右的话就想象成上下吧朋友，栈是下面封底，上面进上面出；队列是上面是队尾进，下面是队头出。

# 证明思路
构造合法的出栈序列与不合法的出栈序列之间的关系
1. n个元素，固定排序，2n次操作，n次进栈和n次出栈, $C_{2n}^{n}$。


2. **分析不合法的出栈序列的特征并计算其数量**
   - 对于一个不合法的出栈序列，一定存在一个最小的\(k\)，使得前\(2k + 1\)次操作中，出栈操作比进栈操作多\(1\)次（即第\(2k + 1\)次操作是出栈，且前\(2k\)次操作中出栈比进栈多\(0\)次）。
   - 由于前\(2k + 1\)次操作中出栈比进栈多\(1\)次，那么在剩下的\(2n-(2k + 1)\)次操作中，进栈操作比出栈操作多\(1\)次。
   - 我们对前\(2k + 1\)次操作进行“翻转”，即将进栈操作变为出栈操作，出栈操作变为进栈操作。这样，原来不合法的序列就变成了一个由\(n + 1\)次进栈和\(n - 1\)次出栈组成的操作序列。
   - 反之，任何一个由\(n + 1\)次进栈和\(n - 1\)次出栈组成的操作序列，通过上述“翻转”操作，也能得到一个不合法的出栈序列。
   - 所以，不合法的出栈序列的数量等于从\(2n\)次操作中选择\(n + 1\)次作为进栈操作（剩下\(n - 1\)次为出栈操作）的组合数，即$C_{2n}^{n + 1}=\frac{(2n)!}{(n + 1)!(n - 1)!}$。

3. **计算合法的出栈序列的数量**
   上面两式相减，化简，也就是卡特兰数\(C_n\)的表达式


# 栈与括号匹配
刷题！真的面试考过的题目了  
注意边界检查，看栈是否为空, ```if not stack ```来解决括号数量不平衡的问题
1. ```if not stack or map[stack.pop()] != char: return False ```这行代码确实完成了检查栈空、弹出栈顶元素和检查括号是否匹配这三件事.   
你会的那几种编程语言的```pop()```都不会默认检查栈是否为空，都是模拟栈，然后手动检查。
2. 函数返回是```len(stack) == 0```, 而不是```Ture```,这样才能保证左括号太多的情况是```False```。  
算法结束时栈为空。
```
# 字符串 三种括号 {[(
# 有效括号匹配算法


s='{}[]()'
s='(((((('
# 输入输出也得处理一下

map = {'[':']','{':'}','(':')'}
def T_or_F(s):
    stack = []
    for c in s:
        if c in '{[(':
            stack.append(c)

        elif c in '}])':
            if not stack:  # 这句都不懂，python程序设计真得学一学吧
                return False
            t = stack.pop()
            if map[t] != c:
                return False

    return len(stack) == 0

print(T_or_F(s))
```
